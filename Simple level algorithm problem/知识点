一．Python基础
1.生成器和迭代器：
区别：生成器能做到迭代器能做的所有事,而且因为自动创建了 iter()和 next()方法,生成器显得特别简洁,而且 生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法,当 发生器终结时,还会自动抛出 StopIteration 异常
迭代器用于访问集合元素。是一个能记住遍历位置的对象，遍历时只能往前，不能后退。迭代器常用方法有 iter() 和 next(). 把一个类作为迭代器使用需要在类中实现两个函数：__iter__() 和 __next__().
使用了 yield 的函数称为生成器，生成器函数返回一个迭代器。在调用生成器运行的过程中，每次遇到 yield 时函数会暂停运行然后保存当前信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。

2.单例模式
一个类只能用一个实例，就是不管你遇到多少个女神，你只能有一个老婆，
单例模式应用的场景一般发现在以下条件下： 
（1）资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如日志文件，应用配置。 
（2）控制资源的情况下，方便资源之间的互相通信。如线程池等。 1.网站的计数器 2.应用配置 3.多线程池 4. 数据库配置，数据库连接池 5.应用程序的日志应用....

3.进程线程协程
进程：一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所有进程间数据不共享，开销大。
线程: cpu调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在，一个进程至少有一个线程，叫主线程，多个线程共享内存（数据共享，共享全局变量),极大地提高了程序的运行效率。
多线程适合io操作密集型的任务文件操作；
多进程适合cpu密集操作型的任务，主要使用cpu来计算，如大量的数学计算
协程: 是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。
协程调度时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操中栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

4.同步，异步，阻塞，非阻塞，并行，并发
同步：多个任务之间有先后顺序执行，一个执行完下个才能执行。 
异步：多个任务之间没有先后顺序，可以同时执行有时候一个任务可能要在必要的时候获取另一个 同时执行的任务的结果，这个就叫回调！
阻塞：如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。 
非阻塞：如果不会卡住，可以继续执行，就是说非阻塞的。 
同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。
并行：同一时刻多个任务同时在运行。 
并发：在同一时间间隔内多个任务都在运行，但是并不会在同一时刻同时运行，存在交替执行的情况
线程是并发，进程是并行；

5.可变和不可变类型
Python中，数值类型（int 和 float）、字符串str、元组 tuple都是不可变类型。而列表 list、字典dict、集合set是可变类型。

6.linux
lsof -i:端口号，用于查看某一端口的占用情况，比如查看22号端口使用情况，lsof -i:22
netstat -tunlp用于显示tcp，udp的端口和进程等
top：Cpu使用情况
netstat  -anp  |grep   端口号：查看端口占用情况

7.匿名函数
1.匿名的目的就是要没有名字，给匿名函数赋给一个名字是没有意义的。
2.匿名函数的参数规则、作用域关系与有名函数是一样的。
3.匿名函数的函数体通常应该是 一个表达式,该表达式必须要有一个返回值。
匿名函数优点
1.使用Python写一些脚本时，使用lambda可以省去定义函数的过程，让代码更加精简。
2.对于一些抽象的，不会被别的地方再重复使用的函数，有时候函数起个名字也是个难题，使用lambda不需要考虑命名的问题
3.使用lambda在某些时候然后代码更容易理解
8.弱引用
是指不能确保他的引用的对象不会被垃圾回收器回收的引用。
弱引用的创建：使用weakref模块，你可以创建到对象的弱引用，Python在对象的引用计数为0或只存在对象的弱引用时将回收这个对象。

9.猴子补丁
属性在运行时的动态替换，叫做猴子补丁
比如我们引用通用库里的一个模块，又想丰富模块的功能，除了继承之外也可以考虑用猴子补丁

10.鸭子类型和多态
多态：
多个子类中虽然都具有同一个方法，但是这些子类实例化的对象调用这些相同的方法后却 可以获得完全不同的结果，多态性增强了软件的灵活性。
Python中多态的特点
1、只关心对象的实例方法是否同名，不关心对象所属的类型；
2、对象所属的类之间，继承关系可有可无；
3、多态的好处可以增加代码的外部调用灵活度，让代码更加通用，兼容性比较强；
4、多态是调用方法的技巧，不会影响到类的内部设计。
多态的应用场景
1. 对象所属的类之间没有继承关系
调用同一个函数, 传入不同的参数（对象），可以达成不同的功能
2. 对象所属的类之间有继承关系（应用更广）
鸭子类型：
是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由"当前方法和属性的集合"决定。
关注点在于对象的行为，能作什么；而不是关注对象所属的类型。
11.Python 中的__new__和__init__的区别
相同：二者均是Python面向对象语言中的函数，__new__比较少用，__init__则用的比较多。
不同：__new__是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例对象，是个静态方法。
__init__是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值，通常用在初始化一个类实例的时候。是一个实例方法。
也就是： __new__先被调用，__init__后被调用，__new__的返回值（实例）将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数。

二．Django生命周期
1.当用户在浏览器中输入url时,浏览器会生成请求头和请求体发给服务端 请求头和请求体中会包含浏览器的请求方式，通常为get或者post,体现在url之中.
2.url经过Django中的wsgi,再经过Django的中间件,最后url到过路由映射表,在路由中一条一条进行匹配, 一旦其中一条匹配成功就执行对应的视图函数,后面的路由就不再继续匹配了. 
3.视图函数根据客户端的请求查询相应的数据.返回给Django,然后Django数据返回给客户端.
4.客户端浏览器接收到返回的数据,经过渲染后显示给用户.

三．POST和GET
GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中。

GET和POST是什么？HTTP协议中的两种发送请求的方法。
HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 
GET和POST还有一个重大区别，简单的说：
GET产生一个TCP数据包；POST产生两个TCP数据包。
长的说：
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应
而对于POST，浏览器先发送header，服务器响应，浏览器再发送data，服务器响应因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。
1. GET与POST都有自己的语义，不能随便混用。
2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

四．HTTP和HTTPS
1、HTTPS 协议需要到CA证书
2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。
3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

五．TCP和UDP
TCP协议保证数据传输可靠性的方式主要有：
校验和
序列号
确认应答
超时重传
连接管理
流量控制
拥塞控制
https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html
UDP是面向无连接的通讯协议，UDP 数据包括目的端口号和源端口号信息。 
优点：UDP 速度快、操作简单、要求系统资源较少，由于通讯不需要连接，可以实现广播发送 
缺点：UDP 传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，也不重复发送，不可靠。

TCP是面向连接的通讯协议，通过三次握手建立连接，通讯完成时四次挥手 
优点：TCP 在数据传递时，有确认、窗口、重传、阻塞等控制机制，能保证数据正确性，较为可靠。 
缺点：TCP 相对于 UDP 速度慢一点，要求系统资源较多。

六．Celery
1、客户端发布任务
2、发布的任务存到任务队列queue里面，数据库存储任务实现broker中间人，然后用多个 worker去监听队列里的任务去执行
3、任务处理者会不断从任务队列里面获取任务执行


七．MySQL
1.主键和唯一索引区别
主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。
主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。
唯一性索引列允许空值，而主键列不允许为空值。
主键列在创建时，已经默认为非空值 + 唯一索引了。
主键可以被其他表引用为外键，而唯一索引不能。
一个表最多只能创建一个主键，但可以创建多个唯一索引。
主键和唯一索引都可以有多列。
主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。
在 RBO 模式下，主键的执行计划优先级要高于唯一索引。 两者可以提高查询的速度。
索引是一种特殊的文件（InnoDB数据表上的索引是表空间的一个组成部分），它们包含着对数据表里所有记录的引用指针。
其实主键和索引都是键，不过主键是逻辑键，索引是物理键，意思就是主键不实际存在，而索引实际存在在数据库中，主键一般都要建，主要是用来避免一张表中有相同的记录，索引一般可以不建，但如果需要对该表进行查询操作，则最好建，这样可以加快检索的速度。
2.为什么使用数据索引能提高效率
数据索引的存储是有序的
在有序的情况下，通过索引查询一个数据是无需遍历索引记录的
极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)
3.事务隔离级别
第一种隔离级别：Read uncommitted(读未提交)
如果一个事务已经开始写数据，则另外一个事务不允许同时进行写操作，但允许其他事务读此行数据，该隔离级别可以通过“排他写锁”，但是不排斥读线程实现。这样就避免了更新丢失，却可能出现脏读，也就是说事务B读取到了事务A未提交的数据
解决了更新丢失，但还是可能会出现脏读
第二种隔离级别：Read committed(读提交)Sql Server , Oracle默认
如果是一个读事务(线程)，则允许其他事务读写，如果是写事务将会禁止其他事务访问该行数据，该隔离级别避免了脏读，但是可能出现不可重复读。事务A事先读取了数据，事务B紧接着更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。
解决了更新丢失和脏读问题
第三种隔离级别：Repeatable read(可重复读取)MySQL默认
可重复读取是指在一个事务内，多次读同一个数据，在这个事务还没结束时，其他事务不能访问该数据(包括了读写)，这样就可以在同一个事务内两次读到的数据是一样的，因此称为是可重复读隔离级别，读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务(包括了读写)，这样避免了不可重复读和脏读，但是有时可能会出现幻读。(读取数据的事务)可以通过“共享读镜”和“排他写锁”实现。
解决了更新丢失、脏读、不可重复读、但是还会出现幻读
第四种隔离级别：Serializable(可序化)
提供严格的事务隔离，它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行，如果仅仅通过“行级锁”是无法实现序列化的，必须通过其他机制保证新插入的数据不会被执行查询操作的事务访问到。序列化是最高的事务隔离级别，同时代价也是最高的，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻读
解决了更新丢失、脏读、不可重复读、幻读(虚读)
4.MySQL引擎
（1）InnoDB存储引擎
InnoDB给MySQL的表提供了事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全。在MySQL从3.23.34a开始包含InnnoDB。它是MySQL上第一个提供外键约束的表引擎。而且InnoDB对事务处理的能力，也是其他存储引擎不能比拟的。靠后版本的MySQL的默认存储引擎就是InnoDB。
InnoDB存储引擎总支持AUTO_INCREMENT。自动增长列的值不能为空，并且值必须唯一。MySQL中规定自增列必须为主键。在插入值的时候，如果自动增长列不输入值，则插入的值为自动增长后的值；如果输入的值为0或空（NULL），则插入的值也是自动增长后的值；如果插入某个确定的值，且该值在前面没有出现过，就可以直接插入。
InnoDB还支持外键（FOREIGN KEY）。外键所在的表叫做子表，外键所依赖（REFERENCES）的表叫做父表。父表中被字表外键关联的字段必须为主键。当删除、更新父表中的某条信息时，子表也必须有相应的改变，这是数据库的参照完整性规则。
InnoDB中，创建的表的表结构存储在.frm文件中（我觉得是frame的缩写吧）。数据和索引存储在innodb_data_home_dir和innodb_data_file_path定义的表空间中。
InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。
（2）MyISAM存储引擎
MyISAM是MySQL中常见的存储引擎，曾经是MySQL的默认存储引擎。MyISAM是基于ISAM引擎发展起来的，增加了许多有用的扩展。
MyISAM的表存储成3个文件。文件的名字与表名相同。拓展名为frm、MYD、MYI。其实，frm文件存储表的结构；MYD文件存储数据，是MYData的缩写；MYI文件存储索引，是MYIndex的缩写。
基于MyISAM存储引擎的表支持3种不同的存储格式。包括静态型、动态型和压缩型。其中，静态型是MyISAM的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到myisampack工具，占用的磁盘空间较小。
MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。
（3）MEMORY存储引擎
MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。
每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。
MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。
注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。
5.数据库优化查询
（1）储存引擎选择：如果数据表需要事务处理，应该考虑使用 InnoDB，因为它完全符合 ACID特性。 如果不需要事务处理，使用默认存储引擎 MyISAM 是比较明智的。（2）分表分库，主从。 （3）对查询进行优化，要尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。（4）应尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表扫描。（5）应尽量避免在where子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。（6）应尽量避免在 where 子句中使用or来连接条件，如果一个字段有索引，一个字段没有索引， 将导致引擎放弃使用索引而进行全表扫描。（7）Update 语句，如果只更改 1、2 个字段，不要 Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。（8）对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再 JOIN，否则逻辑读会很高，性能很差。
6.数据库的优化
（1）优化索引、SQL 语句、分析慢查询；（2）设计表的时候严格根据数据库的设计范式来设计数据库；（3）使用缓存，把经常访问到的数据而且不需要经常变化的数据放在缓存中，能节约磁盘IO （4）优化硬件；采用 SSD，使用磁盘队列技术(RAID0,RAID1,RDID5)等.（5）采用 MySQL 内部自带的表分区技术，把数据分层不同的文件，能够提高磁盘的读取效率； （6）垂直分表；把一些不经常读的数据放在一张表里，节约磁盘 I/O；（7）主从分离读写；采用主从复制把数据库的读操作和写入操作分离开来；（8）分库分表分机器（数据量特别大），主要的的原理就是数据路由；（9）选择合适的表引擎，参数上的优化。（10）进行架构级别的缓存，静态化和分布式；（11）不采用全文索引；（12）采用更快的存储方式，例如 NoSQL 存储经常访问的数据
7.数据库负载均衡
负载均衡集群是由一组相互独立的计算机系统构成，通过常规网络或专用网络进行连接，由路 由器衔接在一起，各节点相互协作、共同负载、均衡压力，对客户端来说，整个群集可以视为一台具有超高性能的独立服务器。
（1）实现原理：首先要有一个可以控制连接数据库的控制端。在这里，它截断了数据库和程序的直接连接，由所有的程序来访问这个中间层，然后再由中间层来访问数据库。这样，我们就可以具体控制访问某个数据库了，然后还可以根据数据库的当前负载采取有效的均衡策略， 来调整每次连接到哪个数据库。
（2）实现多据库数据同步
对于负载均衡，最重要的就是所有服务器的数据都是实时同步的。这是一个集群所必需的，因 为，如果数不据实时、不同步，那么用户从一台服务器读出的数据，就有别于从另一台服务器读出 的数据，这是不能允许的。所以必须实现数据库的数据同步。这样，在查询的时候就可以有多个资 源，实现均衡。比较常用的方法是 Moebius for SQL Server 集群，Moebius for SQL Server 集群 采用将核心程序驻留在每个机器的数据库中的办法，这个核心程序称为 Moebius for SQL Server 中间件，主要作用是监测数据库内数据的变化并将变化的数据同步到其他数据库中。数据同步完成 后客户端才会得到响应，同步过程是并发完成的，所以同步到多个数据库和同步到一个数据库的时 间基本相等；另外同步的过程是在事务的环境下完成的，保证了多份数据在任何时刻数据的一致性。 正因为 Moebius 中间件宿主在数据库中的创新，让中间件不但能知道数据的变化，而且知道引起 数据变化的 SQL 语句，根据 SQL 语句的类型智能的采取不同的数据同步的策略以保证数据同步成 本的最小化。 数据条数很少，数据内容也不大，则直接同步数据。数据条数很少，但是里面包含大数据类型， 比如文本，二进制数据等，则先对数据进行压缩然后再同步，从而减少网络带宽的占用和传输所用 的时间。 数据条数很多，此时中间件会拿到造成数据变化的 SQL 语句， 然后对 SQL 语句进行解析，分 析其执行计划和执行成本，并选择是同步数据还是同步 SQL 语句到其他的数据库中。此种情况应用 在对表结构进行调整或者批量更改数据的时候非常有用。 
（3）优缺点 
优点： 1) 扩展性强：当系统要更高数据库处理速度时，只要简单地增加数据库服务器就 可以得到扩展。 2) 可维护性：当某节点发生故障时，系统会自动检测故障并转移故障节点的应用，保证数据库的持续工作。3) 安全性：因为数据会同步的多台服务器上，可以实现数据集的冗余，通过多份数据来保证安全性。 另外它成功地将数据库放到了内网之中，更好地保护了数据库的安全性。 4) 易用性：对应用来说完全透明，集群暴露出来的就是一个 IP 缺点：a) 不能够按照 Web 服务器的处理能力分配负载。 b) 负载均衡器(控制端)故障，会导致整个数据库系统瘫痪。
8.key和index的区别
key 是数据库的物理结构，它包含两层意义和作用，一是约束（偏重于约束和规范数据库的结构完整性），二是索引（辅助查询用的）。包括primary key, unique key, foreign key 等
index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等；
八．Redis
https://www.cnblogs.com/javazhiyin/p/13839357.html
1.redis缓存穿透，缓存击穿，缓存雪崩
（1）缓存穿透：key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。
解决：①采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
②如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，
（2）缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮
解决：在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。把后端DB压垮。
（3）缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。
解决：加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。
九．WEB安全
常见的攻击https://cnblogs.com/morethink/p/8734103.html
常见的攻击https://blog.csdn.net/loongshawn/article/details/88047373

十．HIPS，RASP,WAF
WAF是门卫模型，通常部署在Web应用系统的外部边界，所有正常或恶意流量都需要通过特征规则和模式识别，通过特定的规则和模式识别出恶意请求，并且把它们拒之门外，拒绝向高风险的Web请求提供服务。
WAF虽然可以有效个过滤出绝大多数恶意请求，但是不知道应用运行时的上下文，必然会造成一定程度的误报。并且WAF严重依赖于特征库，各种花式绕过，导致特征编写很难以不变应万变。如果黑客只是进行了简单扫描文件操作，这很可能就是自动化程序进行的扫描，产生威胁的可能性非常小。但是由于WAF不掌握应用内部的信息，它没办法判断扫描的危害性有多大，因此保险起见只能报警。

RASP的不同就在于运行在应用之中，就像贴身保镖一样与应用融为一体，可以获取到应用运行时的上下文行为，根据运行时上下文或者敏感行为操作，对攻击进行精准的识别或拦截。
监控点位于应用程序的输入输出位置（输入点包括用户请求、文件输入等；输出点包括包括数据库、网络、文件系统等）

HIPS可提供三种防御：应用程序防御体系AD、注册表防御体系RD、文件防御体系FD
应用程序防御体系（AD）在大部分HIPS里属于最重要的功能，AD通过拦截系统调用函数来达到监视目的，当一个程序请求执行时，系统会记录该程序的宿主（即该程序的执行请求由哪个程序发出），在Windows里，用户启动的程序，其宿主为Windows外壳程序Explorer.exe，因为用户的交互界面是由该程序负责的，用户双击鼠标执行一个程序时，实际上就是通过Explorer.exe向内核传递的消息，于是它便成为用户程序的宿主；而并非所有程序都是通过Explorer.exe执行的，系统自身也执行着许多基本进程，这些进程几乎都由smss.exe所产生，而这些通过smss.exe产生的进程又能成为其它进程的宿主，如services.exe成为svchost.exe的宿主等，这些层层叠叠的关系被称为“进程树”（Process Tree）。基于这个原理，许多伪造成系统程序的木马其实很容易被发现，因为它们大部分通过系统启动项加载，而这个启动项是属于Explorer.exe负责的，于是木马们的宿主就成了它——csrss.exe居然由Explorer.exe加载运行，这本身就违背了系统设计的初衷。

十一．FastDFS
1、什么是FastDFS?
FastDFS是用C语言编写的一款开源的分布式文件系统。使用 FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。
2、FastDFS有哪些架构?
Tracker server 和Storage server。
客户端请求Tracker server进行文件上传、下载，通过 Tracker server 调度最终由Storage server 完成文件上传和下载。Tracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。
Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上，
3、FastDFS服务端有哪些角色?
答：Tracker：管理集群，tracker 也可以实现集群。每个tracker节点地位平等，收集Storage集群的状态。
Storage：实际保存文件Storage分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的。
4、FastDFS的交互过程是怎样的？
答：-client询问tracker上传到的storage，不需要附加参数;
-tracker返回一台可用的storage;
-client直接和storage通讯完成文件上传。
5、FastDFS有哪些优缺点？
Fastdfs优点：（1）主备Tracker服务，增强系统的可用性；（2）系统不需要支持POSIX，这样的话就降低了系统的复杂度，使得处理的速度会更高；（3）支持主从文件，支持自定义扩展名；（4）支持在线扩容机制，增强了系统的可扩展性；（5）实现了软RAID，增强了系统的并发处理能力和数据容错恢复能力
FastDFS缺点：（1）通过API下载，存在单点的性能瓶颈；（2）不支持断点续传，对大文件将是噩梦；（3）同步机制不支持文件正确性校验，降低了系统的可用性；（4）不支持POSIX通用接口访问，通用性比较的低；（5）对跨公网的文件同步，存在着比较大的延迟，需要应用做相应的容错策略

7、FastDFS特性有哪些?
（1）Tracker服务器是系统的核心，负责访问调度(负载均衡)，监控管理Storage服务器
（2）在文件同步上，只有同组的Storage才做同步，由文件所在的源Storage服务器push至其它Storage服务器，由于目前对同步后的文件不做正确性校验，因此单个集群点的局部内部网络，如果在公网上使用，肯定会出现损坏文件的情况，需要自行添加文件校验机制。
（3）支持主从文件，非常适合存在关联关系的图片，在存储方式上，FastDFS在主从文件ID上做取巧，完成了关联关系的存储。

十二．Docker
https://www.cnblogs.com/xiaoyangjia/p/11388806.html
1.docker常用命令
docker pull 拉取或者更新指定镜像
docker push 将镜像推送至远程仓库
docker rm 删除容器
docker rmi 删除镜像
docker images 列出所有镜像
docker ps 列出所有容器
2.什么Docker
Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。
3.Docker与虚拟机有何不同
Docker不是虚拟化方法。它依赖于实际实现基于容器的虚拟化或操作系统级虚拟化的其他工具。为此，Docker最初使用LXC驱动程序，然后移动到libcontainer现在重命名为runc。Docker主要专注于在应用程序容器内自动部署应用程序。应用程序容器旨在打包和运行单个服务，而系统容器则设计为运行多个进程，如虚拟机。因此，Docker被视为容器化系统上的容器管理或应用程序部署工具。
A 容器不需要引导操作系统内核，因此可以在不到一秒的时间内创建容器。此功能使基于容器的虚拟化比其他虚拟化方法更加独特和可取。
B 由于基于容器的虚拟化为主机增加了很少或没有开销，因此基于容器的虚拟化具有接近本机的性能。
C 对于基于容器的虚拟化，与其他虚拟化不同，不需要其他软件。
D 主机上的所有容器共享主机的调度程序，从而节省了额外资源的需求。
E 与虚拟机映像相比，容器状态（Docker或LXC映像）的大小很小，因此容器映像很容易分发。
F 容器中的资源管理是通过cgroup实现的。Cgroups不允许容器消耗比分配给它们更多的资源。虽然主机的所有资源都在虚拟机中可见，但无法使用。这可以通过在容器和主机上同时运行top或htop来实现。所有环境的输出看起来都很相似。
4.什么是Docker镜像
Docker镜像是Docker容器的源代码，Docker镜像用于创建容器。使用build命令创建镜像。
5.什么是Docker容器
Docker容器包括应用程序及其所有依赖项，作为操作系统的独立进程运行。
6.Docker容器有几种状态
四种状态：运行、已暂停、重新启动、已退出。
7.Dockerfile中最常见的指令是什么
FROM：指定基础镜像
LABEL：功能是为镜像指定标签
RUN：运行指定的命令
CMD：容器启动时要运行的命令
8.Docker file中的命令COPY和ADD命令有什么区别
COPY与ADD的区别COPY的SRC只能是本地文件，其他用法一致

十三.139和445端口区别
session 1 139和445端口的使用背景
SMB（Server Message Block）协议在NT/2000中用来作文件共享，在Win-NT中，SMB运行于NBT（NetBIOS over TCP/IP）上，使用137，139（UDP），139（TCP）端口。 
在win2000级以上版本中，SMB可以直接运行在tcp/ip上，而没有额外的NBT层，使用TCP 445端口。
session 2 两个端口的使用情况
可以在“网络连接/属性/TCPIP协议/属性/高级/WINS中设置启用或者禁用NBT（NetBIOS over TCP/IP）。 
当计算机同时支持NTB和TCP/IP两种协议的时候，就面临着选择139或者445端口了。下面的情况确定会话使用的端口： 
1、如果客户端启用了NBT，那么连接的时候将同时访问139和445端口，如果从445端口得到回应，那么客户端将发送RST到139端口，终止这个端口的连接，接着就从445端口进行SMB的会话了；如果没有从445端口而是从139得到回应，那么就从139端口进行会话；如果没有得到任何回应，那么SMB会话失败。 
2、如果客户端禁用了NBT，他就将只从445端口进行连接。
3、如果服务器端启用NBT，那么就同时监听UDP 137、138端口和TCP139，445端口。如果禁用NBT，那么就只监听445端口了。 
总结一下：139端口是在NBT协议基础上的，关闭NBT协议139就废了。而445端口是在TCP/IP协议基础上，现在网络中应该很少有不使用TCP/IP协议的了。最后如果主机两种协议同时支持的话（比如windowsxp以后的操作系统）那么共享访问时候的端口使用优先级为：445＞139，所以现在UNC路径访问ip地址都是使用445端口，而访问主机名形式是使用139端口（现在基本不用了）。
关闭139端口的方法：“网络连接/属性/TCPIP协议/属性/高级/WINS中设置启用或者禁用NBT（NetBIOS over TCP/IP）
关闭445端口的方法：防火墙阻塞445端口或者禁用server服务都可以。

十四.常用端口
Linux
服务	端口
ftp（文件传输协议）	20/21
sftp（安全文件传输协议）	115
tftp（udp简单文件传输协议）	69
ssh（安全登录）	22
telnet（远程登录）	23
smtp（邮件传输协议）	25
DNS	53
http	80
https（安全超文件传输协议）	443
rpcbind	111
nfs	2049
ntp（网络时间协议）	123
rsync（rsync文件传输服务）	873
mysql	3306
Oracle	1521
tomcat	8080
window远程终端	3389
zabbix server
zabbix agent	10051
10050
elasticseqrch
logstash
kibana	9200   9300
9301
5601
redis	6379
mongodb	27017

十五.常见排序
https://www.runoob.com/w3cnote/ten-sorting-algorithm.html
