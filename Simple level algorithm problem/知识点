一．Python基础
1.生成器和迭代器：
区别：生成器能做到迭代器能做的所有事,而且因为自动创建了 iter()和 next()方法,生成器显得特别简洁,而且 生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。除了创建和保存程序状态的自动方法,当 发生器终结时,还会自动抛出 StopIteration 异常
迭代器用于访问集合元素。是一个能记住遍历位置的对象，遍历时只能往前，不能后退。迭代器常用方法有 iter() 和 next(). 把一个类作为迭代器使用需要在类中实现两个函数：__iter__() 和 __next__().
使用了 yield 的函数称为生成器，生成器函数返回一个迭代器。在调用生成器运行的过程中，每次遇到 yield 时函数会暂停运行然后保存当前信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。

2.单例模式
一个类只能用一个实例，就是不管你遇到多少个女神，你只能有一个老婆，
单例模式应用的场景一般发现在以下条件下： 
（1）资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如日志文件，应用配置。 
（2）控制资源的情况下，方便资源之间的互相通信。如线程池等。 1.网站的计数器 2.应用配置 3.多线程池 4. 数据库配置，数据库连接池 5.应用程序的日志应用....

3.进程线程协程
进程：一个运行的程序（代码）就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所有进程间数据不共享，开销大。
线程: cpu调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在，一个进程至少有一个线程，叫主线程，多个线程共享内存（数据共享，共享全局变量),极大地提高了程序的运行效率。
多线程适合io操作密集型的任务文件操作；
多进程适合cpu密集操作型的任务，主要使用cpu来计算，如大量的数学计算
协程: 是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。
协程调度时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操中栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

4.同步，异步，阻塞，非阻塞，并行，并发
同步：多个任务之间有先后顺序执行，一个执行完下个才能执行。 
异步：多个任务之间没有先后顺序，可以同时执行有时候一个任务可能要在必要的时候获取另一个 同时执行的任务的结果，这个就叫回调！
阻塞：如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。 
非阻塞：如果不会卡住，可以继续执行，就是说非阻塞的。 
同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。
并行：同一时刻多个任务同时在运行。 
并发：在同一时间间隔内多个任务都在运行，但是并不会在同一时刻同时运行，存在交替执行的情况
线程是并发，进程是并行；

5.可变和不可变类型
Python中，数值类型（int 和 float）、字符串str、元组 tuple都是不可变类型。而列表 list、字典dict、集合set是可变类型。
二．Django生命周期
1.当用户在浏览器中输入url时,浏览器会生成请求头和请求体发给服务端 请求头和请求体中会包含浏览器的请求方式，通常为get或者post,体现在url之中.
2.url经过Django中的wsgi,再经过Django的中间件,最后url到过路由映射表,在路由中一条一条进行匹配, 一旦其中一条匹配成功就执行对应的视图函数,后面的路由就不再继续匹配了. 
3.视图函数根据客户端的请求查询相应的数据.返回给Django,然后Django数据返回给客户端.
4.客户端浏览器接收到返回的数据,经过渲染后显示给用户.

三．POST和GET
GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中。

GET和POST是什么？HTTP协议中的两种发送请求的方法。
HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 
GET和POST还有一个重大区别，简单的说：
GET产生一个TCP数据包；POST产生两个TCP数据包。
长的说：
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应
而对于POST，浏览器先发送header，服务器响应，浏览器再发送data，服务器响应因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。
1. GET与POST都有自己的语义，不能随便混用。
2. 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。
3. 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。

四．HTTP和HTTPS
1、HTTPS 协议需要到CA证书
2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。
3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)

五．TCP和UDP
https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html
UDP是面向无连接的通讯协议，UDP 数据包括目的端口号和源端口号信息。 
优点：UDP 速度快、操作简单、要求系统资源较少，由于通讯不需要连接，可以实现广播发送 
缺点：UDP 传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数 据是否会正确接收，也不重复发送，不可靠。

TCP是面向连接的通讯协议，通过三次握手建立连接，通讯完成时四次挥手 
优点：TCP 在数据传递时，有确认、窗口、重传、阻塞等控制机制，能保证数据正确性，较为可靠。 
缺点：TCP 相对于 UDP 速度慢一点，要求系统资源较多。

六．Celery
1、客户端发布任务
2、发布的任务存到任务队列queue里面，数据库存储任务实现broker中间人，然后用多个 worker去监听队列里的任务去执行
3、任务处理者会不断从任务队列里面获取任务执行


七．MySQL
https://www.cnblogs.com/williamjie/p/11081592.html

八．Redis
https://www.cnblogs.com/javazhiyin/p/13839357.html

九．WEB安全
常见的攻击https://cnblogs.com/morethink/p/8734103.html
常见的攻击https://blog.csdn.net/loongshawn/article/details/88047373

十．HIPS，RASP,WAF
WAF是门卫模型，通常部署在Web应用系统的外部边界，所有正常或恶意流量都需要通过特征规则和模式识别，通过特定的规则和模式识别出恶意请求，并且把它们拒之门外，拒绝向高风险的Web请求提供服务。
WAF虽然可以有效个过滤出绝大多数恶意请求，但是不知道应用运行时的上下文，必然会造成一定程度的误报。并且WAF严重依赖于特征库，各种花式绕过，导致特征编写很难以不变应万变。如果黑客只是进行了简单扫描文件操作，这很可能就是自动化程序进行的扫描，产生威胁的可能性非常小。但是由于WAF不掌握应用内部的信息，它没办法判断扫描的危害性有多大，因此保险起见只能报警。

RASP的不同就在于运行在应用之中，就像贴身保镖一样与应用融为一体，可以获取到应用运行时的上下文行为，根据运行时上下文或者敏感行为操作，对攻击进行精准的识别或拦截。
监控点位于应用程序的输入输出位置（输入点包括用户请求、文件输入等；输出点包括包括数据库、网络、文件系统等）

HIPS可提供三种防御：应用程序防御体系AD、注册表防御体系RD、文件防御体系FD
应用程序防御体系（AD）在大部分HIPS里属于最重要的功能，AD通过拦截系统调用函数来达到监视目的，当一个程序请求执行时，系统会记录该程序的宿主（即该程序的执行请求由哪个程序发出），在Windows里，用户启动的程序，其宿主为Windows外壳程序Explorer.exe，因为用户的交互界面是由该程序负责的，用户双击鼠标执行一个程序时，实际上就是通过Explorer.exe向内核传递的消息，于是它便成为用户程序的宿主；而并非所有程序都是通过Explorer.exe执行的，系统自身也执行着许多基本进程，这些进程几乎都由smss.exe所产生，而这些通过smss.exe产生的进程又能成为其它进程的宿主，如services.exe成为svchost.exe的宿主等，这些层层叠叠的关系被称为“进程树”（Process Tree）。基于这个原理，许多伪造成系统程序的木马其实很容易被发现，因为它们大部分通过系统启动项加载，而这个启动项是属于Explorer.exe负责的，于是木马们的宿主就成了它——csrss.exe居然由Explorer.exe加载运行，这本身就违背了系统设计的初衷。

十一．FastDFS
1、什么是FastDFS?
FastDFS是用C语言编写的一款开源的分布式文件系统。使用 FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。
2、FastDFS有哪些架构?
Tracker server 和Storage server。
客户端请求Tracker server进行文件上传、下载，通过 Tracker server 调度最终由Storage server 完成文件上传和下载。Tracker server 作用是负载均衡和调度，通过 Tracker server 在文件上传时可以根据一些策略找到 Storage server 提供文件上传服务。可以将 tracker 称为追踪服务器或调度服务器。
Storage server 作用是文件存储，客户端上传的文件最终存储在 Storage 服务器上，
3、FastDFS服务端有哪些角色?
答：Tracker：管理集群，tracker 也可以实现集群。每个tracker节点地位平等，收集Storage集群的状态。
Storage：实际保存文件Storage分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的。
4、FastDFS的交互过程是怎样的？
答：-client询问tracker上传到的storage，不需要附加参数;
-tracker返回一台可用的storage;
-client直接和storage通讯完成文件上传。
5、FastDFS有哪些优缺点？
Fastdfs优点：（1）主备Tracker服务，增强系统的可用性；（2）系统不需要支持POSIX，这样的话就降低了系统的复杂度，使得处理的速度会更高；（3）支持主从文件，支持自定义扩展名；（4）支持在线扩容机制，增强了系统的可扩展性；（5）实现了软RAID，增强了系统的并发处理能力和数据容错恢复能力
FastDFS缺点：（1）通过API下载，存在单点的性能瓶颈；（2）不支持断点续传，对大文件将是噩梦；（3）同步机制不支持文件正确性校验，降低了系统的可用性；（4）不支持POSIX通用接口访问，通用性比较的低；（5）对跨公网的文件同步，存在着比较大的延迟，需要应用做相应的容错策略

7、FastDFS特性有哪些?
（1）Tracker服务器是系统的核心，负责访问调度(负载均衡)，监控管理Storage服务器
（2）在文件同步上，只有同组的Storage才做同步，由文件所在的源Storage服务器push至其它Storage服务器，由于目前对同步后的文件不做正确性校验，因此单个集群点的局部内部网络，如果在公网上使用，肯定会出现损坏文件的情况，需要自行添加文件校验机制。
（3）支持主从文件，非常适合存在关联关系的图片，在存储方式上，FastDFS在主从文件ID上做取巧，完成了关联关系的存储。

十二．Docker
https://junmoxiao.blog.csdn.net/article/details/107442065
1.docker常用命令
docker pull 拉取或者更新指定镜像
docker push 将镜像推送至远程仓库
docker rm 删除容器
docker rmi 删除镜像
docker images 列出所有镜像
docker ps 列出所有容器
2.什么Docker
Docker是一个容器化平台，它以容器的形式将您的应用程序及其所有依赖项打包在一起，以确保您的应用程序在任何环境中无缝运行。
3.Docker与虚拟机有何不同
Docker不是虚拟化方法。它依赖于实际实现基于容器的虚拟化或操作系统级虚拟化的其他工具。为此，Docker最初使用LXC驱动程序，然后移动到libcontainer现在重命名为runc。Docker主要专注于在应用程序容器内自动部署应用程序。应用程序容器旨在打包和运行单个服务，而系统容器则设计为运行多个进程，如虚拟机。因此，Docker被视为容器化系统上的容器管理或应用程序部署工具。
A 容器不需要引导操作系统内核，因此可以在不到一秒的时间内创建容器。此功能使基于容器的虚拟化比其他虚拟化方法更加独特和可取。
B 由于基于容器的虚拟化为主机增加了很少或没有开销，因此基于容器的虚拟化具有接近本机的性能。
C 对于基于容器的虚拟化，与其他虚拟化不同，不需要其他软件。
D 主机上的所有容器共享主机的调度程序，从而节省了额外资源的需求。
E 与虚拟机映像相比，容器状态（Docker或LXC映像）的大小很小，因此容器映像很容易分发。
F 容器中的资源管理是通过cgroup实现的。Cgroups不允许容器消耗比分配给它们更多的资源。虽然主机的所有资源都在虚拟机中可见，但无法使用。这可以通过在容器和主机上同时运行top或htop来实现。所有环境的输出看起来都很相似。
4.什么是Docker镜像
Docker镜像是Docker容器的源代码，Docker镜像用于创建容器。使用build命令创建镜像。
5.什么是Docker容器
Docker容器包括应用程序及其所有依赖项，作为操作系统的独立进程运行。
6.Docker容器有几种状态
四种状态：运行、已暂停、重新启动、已退出。
7.Dockerfile中最常见的指令是什么
FROM：指定基础镜像
LABEL：功能是为镜像指定标签
RUN：运行指定的命令
CMD：容器启动时要运行的命令
8.Dockerfile中的命令COPY和ADD命令有什么区别
COPY与ADD的区别COPY的SRC只能是本地文件，其他用法一致

十三.139和445端口区别
session 1 139和445端口的使用背景
SMB（Server Message Block）协议在NT/2000中用来作文件共享，在Win-NT中，SMB运行于NBT（NetBIOS over TCP/IP）上，使用137，139（UDP），139（TCP）端口。 
在win2000级以上版本中，SMB可以直接运行在tcp/ip上，而没有额外的NBT层，使用TCP 445端口。
session 2 两个端口的使用情况
可以在“网络连接/属性/TCPIP协议/属性/高级/WINS中设置启用或者禁用NBT（NetBIOS over TCP/IP）。 
当计算机同时支持NTB和TCP/IP两种协议的时候，就面临着选择139或者445端口了。下面的情况确定会话使用的端口： 
1、如果客户端启用了NBT，那么连接的时候将同时访问139和445端口，如果从445端口得到回应，那么客户端将发送RST到139端口，终止这个端口的连接，接着就从445端口进行SMB的会话了；如果没有从445端口而是从139得到回应，那么就从139端口进行会话；如果没有得到任何回应，那么SMB会话失败。 
2、如果客户端禁用了NBT，他就将只从445端口进行连接。
3、如果服务器端启用NBT，那么就同时监听UDP 137、138端口和TCP139，445端口。如果禁用NBT，那么就只监听445端口了。 
总结一下：139端口是在NBT协议基础上的，关闭NBT协议139就废了。而445端口是在TCP/IP协议基础上，现在网络中应该很少有不使用TCP/IP协议的了。最后如果主机两种协议同时支持的话（比如windowsxp以后的操作系统）那么共享访问时候的端口使用优先级为：445＞139，所以现在UNC路径访问ip地址都是使用445端口，而访问主机名形式是使用139端口（现在基本不用了）。
关闭139端口的方法：“网络连接/属性/TCPIP协议/属性/高级/WINS中设置启用或者禁用NBT（NetBIOS over TCP/IP）
关闭445端口的方法：防火墙阻塞445端口或者禁用server服务都可以。
